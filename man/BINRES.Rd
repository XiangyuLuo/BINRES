% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BINRES.R
\name{BINRES}
\alias{BINRES}
\title{Bayesian Integrative Region Segmentation in Spatially Resolved Transcriptomic Studies}
\usage{
BINRES(
  image_data,
  gene_data,
  coord,
  platform = c("ST", "Visium"),
  num_init = 5,
  a_mu_elem = 0,
  B_mu_elem = 1,
  d1 = 3,
  R1_elem = 0.5,
  a_eta = 1,
  b_eta = 1,
  a0 = 0,
  b0 = 1,
  a1 = -10,
  b1 = 5,
  IGkappa = 2,
  IGtau = 10,
  dpAlpha = 1,
  a_beta = 0.7,
  tau_beta = 1,
  tau0 = 0.01,
  tau1 = 0.05,
  M0 = 50,
  geoq = 0.5,
  bernRho = 0.1,
  minPsi1 = 0,
  maxPsi1 = 0.9,
  minPsi2 = 0,
  maxPsi2 = 0.9,
  numOfMCMC = 6000,
  burnIn = 3000,
  trunc_rbeta_by = 10^(-5),
  Is_beta_zero = FALSE,
  Is_warm_start = FALSE,
  Is_logNormPcaGene = FALSE,
  gene_data_pc = NULL,
  Is_print = TRUE,
  print_gap = 10,
  Is_random_seed = TRUE,
  random_seed = 30
)
}
\arguments{
\item{image_data}{p1*n image data matrix. There are p1 features (rows) and n spots (columns).}

\item{gene_data}{p2*n gene expression data matrix. Please DO NOT take logarithm in data preprocessing step..}

\item{coord}{Coordinates dataframe (4 columns). 1st column: first spot coordinate. 2nd column: second spot coordinate. 3rd column: first pixel coordinate. 4th column: second pixel coordinate.}

\item{platform}{Spatial sequencing platform. Used to determine neighborhood structure (ST = square, Visium = hex).}

\item{num_init}{Initial region number. Default is 5.}

\item{a_mu_elem}{Element of vector \eqn{a_\mu}. Default is 0.}

\item{B_mu_elem}{Diagonal element of matrix \eqn{B_\mu}. Default is 1.}

\item{d1}{Degree of freedom for the inverse Wishart prior of \eqn{\Lambda_k}. Default is 3.}

\item{R1_elem}{Diagonal element of matrix R1. Default is 0.5.}

\item{a_eta}{Mean of the normal prior for \eqn{\eta}. Default is 1.}

\item{b_eta}{Standard deviation of the normal prior for \eqn{\eta}. Default is 1.}

\item{a0}{Mean of the normal prior for \eqn{\lambda_0}. Default is 0.}

\item{b0}{Standard deviation of the normal prior for \eqn{\lambda_0}. Default is 1.}

\item{a1}{Mean of the normal distribution before truncation for \eqn{\lambda_1}. Default is -10.}

\item{b1}{Standard deviation of the normal distribution before truncation for \eqn{\lambda_1}. Default is 5.}

\item{IGkappa}{Shape parameter of the inverse gamma prior for \eqn{\sigma_g}. Default is 2.}

\item{IGtau}{Scale parameter of the inverse gamma prior for \eqn{\sigma_g}. Default is 10.}

\item{dpAlpha}{Hyperparameter of the GEM distribution for the stick-breaking prior of \eqn{\pi_k}. That is, \eqn{\xi_i} are drawn from Be(1, dpAlpha). Default is 1.}

\item{a_beta}{Mean of the normal distribution before truncation for the spatial interaction parameter \eqn{\beta}. Default is 0.7.}

\item{tau_beta}{Standard deviation of the normal distribution before truncation for \eqn{\beta}. Default is 1.}

\item{tau0}{Standard deviation of the normal distribution before truncation for the proposal distribution of \eqn{\xi_k^*} when k < M0. Default is 0.01.}

\item{tau1}{Standard deviation of the normal distribution before truncation for the proposal distribution of \eqn{\beta}. Default is 0.05.}

\item{M0}{A relatively large fixed positive integer. Used to determine proposal distribution form of \eqn{\xi_k^*}. Default is 50.}

\item{geoq}{Hyperparameter of the geometric distribution ranging in (0,1). Default is 0.5.}

\item{bernRho}{Hyperparameter of the Bernoulli prior for the marker gene indicator \eqn{\gamma_g}. Default is 0.1.}

\item{minPsi1}{lower bound of the uniform prior for the image contribution weight \eqn{\psi_1}. Default is 0.}

\item{maxPsi1}{upper bound of the uniform prior for the image contribution weight \eqn{\psi_1}. Default is 0.9.}

\item{minPsi2}{lower bound of the uniform prior for the gene-expression contribution weight \eqn{\psi_2}. Default is 0.}

\item{maxPsi2}{upper bound of the uniform prior for the gene-expression contribution weight \eqn{\psi_2}. Default is 0.9.}

\item{numOfMCMC}{Number of MCMC iterations. Default is 6000.}

\item{burnIn}{Number of iterations in burn-in. After burnIn the posterior samples are used and saved to estimate the unknown parameters. Default is 3000.}

\item{trunc_rbeta_by}{Argument "by" in the function "trunc_rbeta". Default is 10^(-5).}

\item{Is_beta_zero}{Logical; if TRUE, \eqn{\beta} is fixed at zero. Default is FALSE.}

\item{Is_warm_start}{Logical; if TRUE, warm start steps by KMeans are used to initialize L1 and L2. Default is FALSE.}

\item{Is_logNormPcaGene}{Logical; if TRUE, a preprocessed gene expression matrix (gene_data_pc) is used for warm start to initialize L2. Default is FALSE.}

\item{gene_data_pc}{n.PCs*n preprocessed gene expression matrix. Obtained by normalizing ST raw count matrix, taking logarithm, and conducting PCA. Required if Is_logNormPcaGene is TRUE. Default is NULL.}

\item{Is_print}{Logical; if TRUE, iteration time information of each update step are printed. Default is TRUE.}

\item{print_gap}{Length of iteration interval to print the current number of iterations. Default is 10.}

\item{Is_random_seed}{Logical; if TRUE, a random seed is used for reproducibility. Default is TRUE.}

\item{random_seed}{Random seed. Required if Is_random_seed is TRUE. Default is 30.}
}
\value{
BINRES returns an R list including the following information.
\item{clIds_mcmc}{matrix, the posterior samples of integrative region indicators for each spot. Rows: MCMC samples. Columns: n spots.}
\item{L1_Ids_mcmc}{matrix, the posterior samples of image-specific cluster indicators for each spot. Rows: MCMC samples. Columns: n spots.}
\item{L2_Ids_mcmc}{matrix, the posterior samples of gene-expression-specific cluster indicators for each spot. Rows: MCMC samples. Columns: n spots.}
\item{mu_k_mcmc}{list, each element contains the posterior sample of \eqn{\mu_k} for all image-specific clusters in each MCMC iteration.}
\item{Lambda_k_mcmc}{list, each element contains the posterior sample of \eqn{\Lambda_k} for all image-specific clusters in each MCMC iteration.}
\item{eta_k_mcmc}{list, each element contains the posterior sample of \eqn{\eta_k} for all gene-expression-specific clusters in each MCMC iteration.}
\item{eta_0_mcmc}{matrix, the posterior samples of \eqn{\eta_0} for each gene. Rows: MCMC samples. Columns: genes.}
\item{sigma_g_mcmc}{matrix, the posterior samples of \eqn{\sigma_g} for each gene. Rows: MCMC samples. Columns: genes.}
\item{gamma_g_mcmc}{matrix, the posterior samples of \eqn{\gamma_g} for each gene. Rows: MCMC samples. Columns: genes.}
\item{lam1_g_mcmc}{matrix, the posterior samples of \eqn{\lambda_1} for each gene. Rows: MCMC samples. Columns: genes.}
\item{lam0_g_mcmc}{matrix, the posterior samples of \eqn{\lambda_0} for each gene. Rows: MCMC samples. Columns: genes.}
\item{pottsBeta_mcmc}{vector, the posterior samples of spatial interaction parameter \eqn{\beta}.}
\item{psi1_mcmc}{vector, the posterior samples of image contribution weight \eqn{\psi_1}.}
\item{psi2_mcmc}{vector, the posterior samples of gene-expression contribution weight \eqn{\psi_2}.}
\item{dpXi_mcmc}{list, each element contains the posterior sample of \eqn{\xi_k} in each MCMC iteration.}
\item{exeTime}{Total execution time of running the code.}
\item{zero_prop_spots}{vector, the spot-wise zero proportions.}
}
\description{
The function BINRES implements a nonparametric Bayesian integrative region
    segmentation method. The ST raw count matrix is normalized to account
    for library sizes WITHOUT taking logarithm. Dropouts and informative
    genes in gene expression data are taken into consideration.
}
\examples{
library(BINRES)
library(aricode)
library(ggplot2)
# Import example data
# (1) coord: Spatial coordinates
# (2) image_data: Simulated image data (normally distributed)
# (3) gene_data: Simulated gene expression data (excess zeros and log-normally distributed)
# (4) true_label: True region labels of all spots
# (5) marker_id: ID number of marker genes
data(example_data_BINRES)
# Dimension of spatial coordinates
dim(coord)
# Dimension of image data
dim(image_data)
# Dimension of gene expression data
dim(gene_data)
# Auxiliary functions
getmode <- function(v) {
  uniqv <- unique(v)
  res <- uniqv[which.max(tabulate(match(v, uniqv)))]
  return(res)
}
# --- run BINRES ---
res_list = BINRES(image_data = image_data, gene_data = gene_data, coord = coord,
                  platform="ST", num_init=5,
                  minPsi1=0, maxPsi1=0.9, minPsi2=0, maxPsi2=0.9,
                  a_beta=0.7, tau_beta=1, tau0=0.01, tau1=0.05,
                  a0=0, b0=1, a1=-10, b1=5,
                  a_mu_elem=0, B_mu_elem=1, d1=3, R1_elem=0.5,
                  a_eta=1, b_eta=1, IGkappa=2, IGtau=10,
                  bernRho=0.1, dpAlpha=1, geoq=0.5,
                  Is_beta_zero=FALSE, Is_logNormPcaGene=FALSE,
                  numOfMCMC=1000, burnIn=500, print_gap=10,
                  Is_warm_start=FALSE, Is_random_seed=TRUE, random_seed=60)
# Posterior mode of consensus clustering C and marker-gene indicator \gamma
clIds_mode = apply(res_list$clIds_mcmc, 2, getmode)
gamma_mode = apply(res_list$gamma_g_mcmc, 2, getmode)
# Compared with true labels
table(clIds_mode, true_label)
cat("ARI value:", ARI(clIds_mode, true_label))
# Visualization
tmpc = clIds_mode
tmpc2 = tmpc
tmpc2[tmpc == 1] = 2
tmpc2[tmpc == 2] = 4
tmpc2[tmpc == 3] = 3
tmpc2[tmpc == 4] = 1
tmpc = tmpc2
plot_color=c("#CC6677", "#53B8EA", "#E2C845", "#03AF3C")
plot_dat <- data.frame(x = coord[,1], y = coord[,2], c = tmpc)
p <- ggplot(data = plot_dat, aes(x=x, y=y)) +
  geom_point(aes(color=factor(c)), size = 3) +
  theme(panel.background = element_blank(),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.title = element_blank()) +
  scale_color_manual(values=plot_color)
p
# 95\% credible interval for spatial interaction parameter \beta
quantile(res_list$pottsBeta_mcmc, c(0.025, 0.975))
# True marker gene ID
cat("True marker gene ID:", marker_id)
# Estimated marker gene ID
cat("Estimated marker gene ID:", which(gamma_mode == 1))
# Computational time
res_list$zero_prop_spots

}
